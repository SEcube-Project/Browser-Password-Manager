\chapter{Implementation Details}

\section{Host Middleware}

The Host Middleware is a software intended to run in the user's PC (for example as a daemon on Linux or as a service on Windows) and to provide a secure connection between the user's PC and the SECube board. This means that it acts as a bridge between the Chromium Extension (the frontend for the user) and the board, thus the Middleware is developed with security in mind.\\

It's main job is to serve some HTTPs requests. In fact, it provides REST APIs to allow the Chromium Extension to interact with the features exposed by the SECube's firmware. This means that it acts as a web server with HTTPs support in order to provide a secure connections.

\subsection{The web server}
HTTPs is a secure protocol that uses a TLS connection to provide a secure connection between two endpoints, and it's a replacement for the HTTP protocol. This means that HTTPs provides the following benefits:

\begin{itemize}
    \item Authentication
    \item Privacy: the connection is encrypted and the data is encrypted
    \item Integrity: the data is signed and the signature is verified
\end{itemize}

Thus, HTTPs helps to avoid the risk of eavesdropping, which is a risk that can be exploited by an attacker to intercept the data and modify it. More in general, it avoids \textit{Man In The Middle} attacks. 

The middleware is developed mainly in Python. To implement the web server, Flask is used as module. It natively supports HTTPs and a self-signed certificate is used, generated with \textit{openssl}.\\

\subsection{The REST APIs}
The exposed APIs are totally complaint to the REST principles. It uses cookies to authenticate the user, and it uses JSON as exchange data format. \\

The main API is the one the allows to create a session. Once a session is created (via a successful authentication), a cookie is generated and sent to the browser. The browser will then store securely the cookie and the extension will automatically attach it to each request. In the end, the cookie is strictly needed to interact with all other APIs.\\

The endpoint to create a session is \texttt{POST /api/v0/device/0/session?pin=<pin>\&enditme=<endt>}. The \texttt{pin} parameter is the PIN code of the board, used to unlock it, while the \texttt{endtime} parameter is the time in seconds until the session expires. When the session expires, the middleware will automatically invalidate it and each subseguent request will result in \texttt{403 Unauthorized}. The \texttt{endtime} parameter is a timestamp in seconds, and it's relative to the middleware's one. The middleware is capable of generating it internally and the current timestamp can be obtained via \texttt{GET /api/v0/time}. For a more complete description of the API, see the appendix \ref{api}.

\subsection{Session Management}
When a cookie is created, it containts only the session ID. This ID is used to identify the session, and it's used to identify the user. The session ID is generated by the middleware and it's unique for each session. This means that on the user's side, only the ID is stored instead of any other sensitive information. The user is protected by \textit{client identity steal} attacks thanks to the security given by the browser in storing it locally.

On the middleware side, a session corresponds to a file stored in the file system, in the same directory as the middleware's executable. The file name is the session ID. The file contains the following information:

\begin{itemize}
    \item The board's PIN given by the user when the session was created
    \item The endtime of the session (timestamp in seconds)
\end{itemize}

In order to avoid possible attacks because of the files stored in clear in the file system, the session is encrypted with a key that is generated by the middleware. At each startup of the middleware, a 2048 bit RSA key is generated and stored in the RAM, and each previously created session is invalidated and destroyed. The public/private keys are used to encrypt/decrypt on the fly the requested session file. The encryption/decryption is done on-the-fly and then the session is stored in the file system, so a non encrypted version of the file will never appear in the file system. Both the PIN and the endtime are encrypted, along with other side informations.

\subsection{Timestamp and Timeout Management}
In order to avoid the risk of \textit{time-leap} or \textit{time travel} attacks, the middleware uses an internal timestamp instead of the PC's one. So, even if a malicious user changes the PC's time, the middleware's timestamp will continue to update itself correctly and sessions will expire correctly.\\

In order to generate the timestamp, the middleware uses a dedicated thread that periodically (each seconds) updates the timestamp. The same information can be accessed via \texttt{GET /api/v0/time}. The timestamp is updated each second, so it's not possible to get a timestamp that is in the past.\\

At each request, the middleware:

\begin{enumerate}
    \item finds the session file corresponding to the session ID in the request (associated to the cookie sent by the Extension)
    \item decrypts the file
    \item gets the stored endtime timestamp
    \item get the current timestamp (so the middleware's timestamp)
    \item compares the endtime with the current timestamp and if the endtime is reached (greater or equal), the session is invalidated and the request is replied with \texttt{403 Unauthorized}
    \item gets the stored PIN
    \item tries to authenticate the user with the PIN
    \item if the \textit{login} is unsuccessful, the request is replied with \texttt{403 Unauthorized}, otherwise the request continues with the operation requested by the user 
\end{enumerate}

\subsection{How to interface Python with C++?}
As mentioned above, the middleware is developed in Python. However, the HOST libraries used to communicate with the board are written in C++. This means that the Python code needs to be able to interface with the C++ libraries. In order to do that, the middleware ues the \textit{Ctypes} module. It's a builtin module that allows to interface with C libraries.\\

The first thing .....