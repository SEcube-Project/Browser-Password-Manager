\chapter{Implementation Details}

\section{Host Middleware}

The Host Middleware is a software intended to run in the user's PC (for example as a daemon on Linux or as a service on Windows) and to provide a secure connection between the user's PC and the SECube board. This means that it acts as a bridge between the Chromium Extension (the frontend for the user) and the board, thus the Middleware is developed with security in mind.\\

It's main job is to serve some HTTPs requests. In fact, it provides REST APIs to allow the Chromium Extension to interact with the features exposed by the SECube's firmware. This means that it acts as a web server with HTTPs support in order to provide a secure connections.

\subsection{The web server}
HTTPs is a secure protocol that uses a TLS connection to provide a secure connection between two endpoints, and it's a replacement for the HTTP protocol. This means that HTTPs provides the following benefits:

\begin{itemize}
    \item Authentication
    \item Privacy: the connection is encrypted and the data is encrypted
    \item Integrity: the data is signed and the signature is verified
\end{itemize}

Thus, HTTPs helps to avoid the risk of eavesdropping, which is a risk that can be exploited by an attacker to intercept the data and modify it. More in general, it avoids \textit{Man In The Middle} attacks. 

The middleware is developed mainly in Python. To implement the web server, Flask is used as module. It natively supports HTTPs and a self-signed certificate is used, generated with \textit{openssl}.\\

\subsection{The REST APIs}
The exposed APIs are totally complaint to the REST principles. It uses cookies to authenticate the user, and it uses JSON as exchange data format. \\

The main API is the one the allows to create a session. Once a session is created (via a successful authentication), a cookie is generated and sent to the browser. The browser will then store securely the cookie and the extension will automatically attach it to each request. In the end, the cookie is strictly needed to interact with all other APIs.\\

The endpoint to create a session is \texttt{POST /api/v0/device/0/session?pin=<pin>\&enditme=<endt>}. The \texttt{pin} parameter is the PIN code of the board, used to unlock it, while the \texttt{endtime} parameter is the time in seconds until the session expires. When the session expires, the middleware will automatically invalidate it and each subseguent request will result in \texttt{403 Unauthorized}. The \texttt{endtime} parameter is a timestamp in seconds, and it's relative to the middleware's one. The middleware is capable of generating it internally and the current timestamp can be obtained via \texttt{GET /api/v0/time}. For a more complete description of the API, see the appendix \ref{api}.

\subsection{Session Management}
When a cookie is created, it containts only the session ID. This ID is used to identify the session, and it's used to identify the user. The session ID is generated by the middleware and it's unique for each session. This means that on the user's side, only the ID is stored instead of any other sensitive information. The user is protected by \textit{client identity steal} attacks thanks to the security given by the browser in storing it locally.

On the middleware side, a session corresponds to a file stored in the file system, in the same directory as the middleware's executable. The file name is the session ID. The file contains the following information:

\begin{itemize}
    \item The board's PIN given by the user when the session was created
    \item The endtime of the session (timestamp in seconds)
\end{itemize}

In order to avoid possible attacks because of the files stored in clear in the file system, the session is encrypted with a key that is generated by the middleware. At each startup of the middleware, a 2048 bit RSA key is generated and stored in the RAM, and each previously created session is invalidated and destroyed. The public/private keys are used to encrypt/decrypt on the fly the requested session file. The encryption/decryption is done on-the-fly and then the session is stored in the file system, so a non encrypted version of the file will never appear in the file system. Both the PIN and the endtime are encrypted, along with other side informations.

\subsection{Timestamp and Timeout Management}
In order to avoid the risk of \textit{time-leap} or \textit{time travel} attacks, the middleware uses an internal timestamp instead of the PC's one. So, even if a malicious user changes the PC's time, the middleware's timestamp will continue to update itself correctly and sessions will expire correctly.\\

In order to generate the timestamp, the middleware uses a dedicated thread that periodically (each seconds) updates the timestamp. The same information can be accessed via \texttt{GET /api/v0/time}. The timestamp is updated each second, so it's not possible to get a timestamp that is in the past.\\

At each request, the middleware:

\begin{enumerate}
    \item finds the session file corresponding to the session ID in the request (associated to the cookie sent by the Extension)
    \item decrypts the file
    \item gets the stored endtime timestamp
    \item get the current timestamp (so the middleware's timestamp)
    \item compares the endtime with the current timestamp and if the endtime is reached (greater or equal), the session is invalidated and the request is replied with \texttt{403 Unauthorized}
    \item gets the stored PIN
    \item tries to authenticate the user with the PIN
    \item if the \textit{login} is unsuccessful, the request is replied with \texttt{403 Unauthorized}, otherwise the request continues with the operation requested by the user 
\end{enumerate}

\subsection{How to interface Python with C++?}
As mentioned above, the middleware is developed in Python. However, the HOST libraries used to communicate with the board are written in C++. This means that the Python code needs to be able to interface with the C++ libraries. In order to do that, the middleware ues the \textit{Ctypes} module. It's a builtin module that allows to interface with C libraries.\\

The actual implementation sees some wrappers (both for the \textit{L0} and \textit{L1} libraries). Those wrappers are C functions that uses only C's primitive types as arguments and as return values, because of the way ctypes works. An example of function wrapper is the following one, used to initialize the \textit{L0} library:

\begin{lstlisting}[style=CStyle]
#ifdef _WIN32
#include <Windows.h>
#define __MODIFIER __declspec(dllexport)
#else
#define __MODIFIER 
#endif

#define EXPORT_FUNC(_type, _name) extern "C" __MODIFIER _type _name

EXPORT_FUNC(void *, createL0Instance)() {
    return new(std::nothrow) L0;
}

\end{lstlisting}

Once C wrappers are all defined and implemented, all the code needs to be compiled. In this case there is no \textit{main} function, so there is no an executable file to run. Because those functions are meant to be called from the external (i.e. the Python code), the code is compiled as a shared library. On linux, they are compiled as \textit{.so} files. On Windows, they are compiled as \textit{.dll} files. The shared library is then loaded by the Python code.\\

With ctypes, the function wrapper is easily invoked. The first thing that is done is to tell to ctypes what are the arguments and return types of the function, then the function can be called. Because this procedure must be done for each function, a python class has been created to encapsulate the functions. There is a class both for the \textit{L0} and \textit{L1} libraries, and this is an example:

\begin{lstlisting}[style=PyStyle]
class L0:
    def __init__(self, path_lib: str):
        self._libname = path_lib
        self._c_lib = ctypes.CDLL(self._libname)

        # Create L0 instance
        self._c_lib.createL0Instance.argtypes = []
        self._c_lib.createL0Instance.restype = ctypes.c_void_p

        self._l0inst = self._c_lib.createL0Instance()
\end{lstlisting}

\subsection{How to secure Python code?}
The python code is not secure. While the C code is compiled into executable code and it's a very difficult job to reverse engineer, the Python code is directly interpreted on the fly, so there is no compilation and the code is in clear. Moreover, it can suffer from \textit{code injection} attacks, so the code must be protected against those attacks.\\

In order to achieve this, a python library is used, called \textit{pyarmor}. Its first job is to obfuscate the code, so write the code in such a way it can't be understood easily by an human. This protects against \textit{code injection} and reverse engineering. The resulting obfuscated script is something like this:

\begin{lstlisting}[style=PyStyle]
from pytransform import pyarmor_runtime
pyarmor_runtime()
__pyarmor__(__name__, __file__, b'\x06\x0f...')
\end{lstlisting}

Moreover, the original python code (that now is obfuscated) is wrapped with functions that insert timers to prevent debugging and to prevent old stack traces dump. This is done by letting the python code run normally and at the end of each function call (where each function call creates a new stack frame), the frame is cleared. \\

Finally, the last precaution is to wrap everything into a single executable. The middleware is mainly composed of different python files, the shared library and the private and public keys. Using a library called \textit{pyinstaller}, the middleware is packed into a single executable. What \textit{pyinstaller} does is to create an executable that when is executed it creates a temporary folder and extract from itself all the files together with a standalone version of the python interpreter. This is done so that the middleware can be executed without the need to install the python interpreter and without the library installed. Moreover, it protects by possible \textit{code injection} attacks done at the interpreter level. The final job of pyinstaller is to encrypt the content of the executable. Beucase the executable needs to know the key to decrypt it when it's requested by the user, the key is hardcoded into the executable itself, so it's relatively easy to obtain the key but a malicious user needs to do some reverse engineering of the executable itself so it's an increase of time spent on trying to attack the middleware. 